# 01. Структура Монорепозитория (Nx Architecture)

Этот документ определяет правила организации кода, управления зависимостями и границы модулей.

## 1. Основные Принципы

1.  **Colocation (Локализация):** Бизнес-логика живет максимально близко к месту использования. Мы не выносим код в библиотеки "на всякий случай". Логика API лежит внутри `apps/api`, логика админки — внутри `apps/admin`.
2.  **Shared Libs (Общие библиотеки):** В папку `libs` попадает только тот код, который **гарантированно** используется двумя и более приложениями (например, DTO, UI-кит, утилиты дат).
3.  **Single Version Policy:** Все приложения используют единые версии внешних зависимостей (React, NestJS, TypeScript), определенных в корневом `package.json`.

## 2. Технологический стек Workspace

- **Инструмент управления:** Nx.
- **Пакетный менеджер:** `pnpm`.
- **Команда создания библиотеки:** `nx g @nx/nest:lib libname`.

### Структура библиотек

Мы разделяем библиотеки на два типа в зависимости от их содержимого:

1.  **NestJS библиотеки (Infrastructure/Logic):**
    - Если библиотека содержит модули, сервисы или другую интеграцию с NestJS (например, `@pif/database`, `@pif/config`).
    - Реализация располагается в директории `src/lib/`.
    - Экспорт всех публичных элементов происходит через `src/index.ts`.
    - _Пример:_ `libs/database/src/lib/database.module.ts` -> экспортируется в `libs/database/src/index.ts`.

2.  **Простые библиотеки (Contracts/Types):**
    - Если библиотека содержит только типы, контракты, Zod-схемы или чистые утилиты (например, `@pif/contracts`).
    - Реализация располагается непосредственно в `src/` (с возможной вложенностью по модулям, но без папки `lib`).
    - Экспорт также через `src/index.ts`.
    - _Пример:_ `libs/contracts/src/animals/commands/create-animal.command.ts` -> экспортируется в `libs/contracts/src/index.ts`.

## 3. Правила Разграничения (Module Boundaries)

Для контроля чистоты архитектуры мы используем правила линтинга `@nx/enforce-module-boundaries`.

### Группы проектов (Tags)

В `project.json` каждого приложения/библиотеки проставляются теги:

- `scope:shared` — Универсальный код (DTO, Utils).
- `scope:frontend` — UI-код (App, Admin, UI-Kit).
- `scope:backend` — Серверный код (API).

### Правила импортов

1.  **Apps (Приложения):**
    - Могут импортировать **Shared Libs** (`scope:shared`).
    - **Frontend Apps** могут импортировать **Frontend Libs**.
    - **Backend Apps** могут импортировать **Backend Libs**.
    - ⛔ **ЗАПРЕЩЕНО:** Одному приложению импортировать код из другого приложения (e.g., `web` не может залезть в `api`).
    - ⛔ **ЗАПРЕЩЕНО:** Приложению импортировать библиотеку не своего скоупа (e.g., `api` не может импортировать `ui-kit`).

2.  **Libs (Библиотеки):**
    - Могут импортировать другие библиотеки своего скоупа или `shared`.
    - ⛔ **ЗАПРЕЩЕНО:** Библиотекам импортировать код из Приложений (`apps/*`). Это создает циклические зависимости.

## 4. Контракты и Типизация (Data Contracts)

Мы используем подход **Code-First Contracts** на базе `Zod`. Это позволяет иметь единый источник истины для валидации на Бэкенде и Фронтенде.

**Паттерн работы:**

1.  Все контракты создаются в библиотеке `libs/contracts`.
2.  Файл контракта экспортирует два артефакта:
    - **Schema (Runtime):** Zod-схема для валидации данных во время выполнения.
    - **DTO:** Класс, наследуемый от функции `createZodDto(createAnimalSchema)`, используется в NestJS для валидации входящих данных.
3.  **Backend Usage:**
    - Схема используется в `ZodValidationPipe` (валидация входящего Body/Query).
    - Тип используется в Controller и Service.
4.  **Frontend Usage:**
    - Схема используется в `react-hook-form` через `zodResolver`.
    - Тип используется как Argument Type для API-клиента.

### Сообщения об ошибках (Zod Messages)

Для пользовательских ошибок валидации используем следующий подход:

- **Статичное сообщение:** Передаем вторым аргументом строку.
  `z.enum(Val, 'Неверное значение')`
- **Динамическое сообщение:** Передаем объект с полем `error`.
  `z.string().max(50, { error: (e) => ({ message: \`Максимум ${e.maximum}\` }) })`

## 5. Работа с зависимостями

- Все зависимости устанавливаются в корень (`pnpm add package-name`).
- Если зависимость нужна только для dev-режима (например, генераторы кода, линтеры), она идет в `devDependencies`.
- Nx автоматически управляет линковкой пакетов внутри воркспейса.
